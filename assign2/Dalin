RC markDirty(BM_BufferPool * const bm, BM_PageHandle * const page)
{
    pf = bm->mapping[page->pageNum];
	while(pf!= null)
	{
		pf.is_dirty = true;
		pf = pf.next;
	}
	return RC_OK;
	
}
//done
RC unpinPage(BM_BufferPool * const bm, BM_PageHandle * const page) 
{
	//Buffer_Storage *bs = (Buffer_Storage *)bm->mgmtData;
//	pf = bm->mapping[page->pageNum];
//	while(pf!= null)
//	{
//		pf.fix_count -= 1;
//		pf = pf.next;
//	}
 //   return RC_OK;
//done
	Buffer_Storage *bs = (Buffer_Storage)bm->mgdata;
	Queue *q = bs->pool;
	int c =0;
	Page_Frame *temp = q->front;
	if(bm->numPages!=NULL){
		while(temp!=NULL){
			if(temp->pageHandle->pageNum == page->pageNum){
				c = temp->fix_count;
				if(c>0){
					temp->fix_count--;
				}
			}
			temp = temp->next;
		}
	return RC_OK;	
	}
	return RC_NOT_OK;
}
RC forcePage(BM_BufferPool * const bm, BM_PageHandle * const page) 
{
  SM_FileHandle fHandle;
  fHandle.fileName = bm->pageFile;
  Buffer_Storage *bs = (Buffer_Storage *)bm->mgmtData;
  openPageFile(bm->pageFile, &fHandle);           
  ensureCapacity(page->pageNum, &fHandle);
  writeBlock(page->pageNum, &fHandle, page->data);
  closePageFile(&fHandle);
  return RC_OK;
}







PageNumber *getFrameContents (BM_BufferPool *const bm)
{
	Buffer_Storage *bs = (Buffer_Storage *)bm->mgmtData;
    PageNumber *arrnumP1 = (PageNumber *)malloc(bm->numPages * sizeof(PageNumber));
	Queue *q = bs->pool;
	Page_Frame p = q->front;
	int i=0;
	while(p!= null)
    {		
        arrnumP[i] = bs->pool.pageHandle->pageNum;
		p = p.next;
		i++;
    }
    return arrnumP1;
}

bool *getDirtyFlags (BM_BufferPool *const bm)
{
    bool *arrnumP2 = (bool *)malloc(bm->numPages * sizeof(bool));
	Buffer_Storage *bs = (Buffer_Storage *)bm->mgmtData;
	Queue *q = bs->pool;
	Page_Frame *temp = q->front;
	int i = 0;
	while(temp!=null)
    {        
       arrnumP2[i] = temp.is_dirty;
	   temp = temp.next;
	   i++
    }
    return arrnumP2;
}
int *getFixCounts (BM_BufferPool *const bm)
{
	Buffer_Storage *bs = (Buffer_Storage *)bm->mgmtData;
    int *arrnumP3 = (int *)malloc(bm->numPages * sizeof(int));
	Queue *q = bs->pool;
	Page_Frame *temp = q->front;
	int i = 0;
	while(temp!= null)
	{
		arrnumP3[i] = temp.fix_count;
		temp = temp.next;
		i++;
	}
	return arrnumP3;
	
}

int getNumReadIO (BM_BufferPool *const bm)
{
	Buffer_Storage *bs = (Buffer_Storage *)bm->mgmtData;
	Queue *q = bs->pool;
	return q-> readIO;
}

int getNumWriteIO (BM_BufferPool *const bm)
{
	Buffer_Storage *bs = (Buffer_Storage *)bm->mgmtData;
	Queue *q = bs->pool;
	return q-> writeIO;
}
